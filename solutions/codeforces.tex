\section{Codeforces}

\ptitle{[CF1763E] Node Pairs}{zmy}
\prob 要求构造一个有向图，恰好有 $p (1 \leq p \leq 2 \cdot 10^5)$ 个点对互相可达。在这个前提下，要求使用的顶点数尽可能少。顶点数相同时，要求单向可达的点对尽可能多
\sol 每个有向图都可以被缩点成一个 DAG,对于每个强连通分量内部肯定是两两可达的，且夸强连通分量的点对一定不是双向可达的。因此我们可以想到用 DP 来计算需要的最小顶点数。再次之上，为了使得单向可达的点对尽可能多，我们的 DAG 一定是一条链的形状，因此我们可以同时 dp 单向可达的点对个数。

\ptitle{[CF1904E] Tree Queries}{shaosy}
\prob 给定一棵树, 多组询问. 每组询问指定一个询问点和一些删除点, 问将删除点删除后树中询问点可达的最远距离为多少
\sol 离线处理. 首先, 询问某一点在书中可达最远距离等价于将该点视为树的根并询问树的深度. 考虑如何换根时更新树的深度. 考虑dfs序. 通过维护每个点的in和out时刻, 配合线段树, 可以用换根dp类似的思想来动态维护每个点当前的深度. 根通过边u-v从u换到v等价于, 给v的子树深度区间减1, 给其他节点深度加1. 然后讨论删除点. 删除点如果在原树中不是新的根节点(x) 的父节点,则可以视作将删除点的子树的深度区间减去正无穷. 而如果是, 则可以视作将除了删除点与点x相连的子树之外所有点的深度区间减去正无穷. 在这种更新下, 当前树的深度就是所有点深度的最大值.

\ptitle{[CF1904F] Beautiful Tree}{shaosy}
\prob 给定一棵树和多组限制条件,要求给树上每一个点赋值使得其成为一个permutation并满足所有限制条件. 每组限制条件形如 u-v-x, 要求使得在路径u-v上的点中x的值最大/最小
\sol 考虑树链剖分+线段树优化建图. 这样, 每一段树上路径可以用不超过$\log{n}$个线段, 每个线段又不超过$\log{n}$个点表示. 建立两颗线段树, 分别表示区间最大的点/区间最小的虚拟点, 而后暴力连边. 暴力连边后跑一边拓扑排序即可. 若存在环,则说明不存在可行解. 线段树优化建图中需要注意为了避免出现自环, 对路径u-v向路径x连边/或其反边连边时, 需要特判x是否在该路径中. 如果在该路径中必须裂成u-x和x-v两段(不包括x)

\ptitle{[CF1903F] Babysitting}{shaosy}
\prob 给定一个图, 选一些点形成一个点覆盖. 要求选的点之间相邻的差最小的最大.
\sol 考虑二分答案后2-SAT. 假设二分的答案为dif. 答案形成点覆盖等价于对每一条边u, v, 必然选择u和v中的一个. 相邻的差至少为dif等价于选择点u, 则不可选择范围为[u - dif + 1, u + dif - 1]中的任意一个点. 这一性质满足2-sat, 可以在其上用线段树优化建图的trick将点数压缩到$O(n)$级别. 对线段树优化建图而言, 可以视作不选择u则必然不选择u * 2和u * 2 + 1

\ptitle{[CF1913E] Matrix Problem}{shaosy}
\prob 给定一个矩阵, 每个矩阵的元素为0或1. 要求修改尽可能少的元素, 使得每一行的和为a[i], 每一列的和为b[i]. $n \leq 50, m \leq 50$
\sol 注意到数据范围很小, 考虑网络流. 如果对矩阵里每个元素建点, 则无法表示同一个点对行和列的贡献. 考虑将矩阵里的每一个点用边来表示, 即, 将$s$ 与行连边,列与$t$连边,点$i-j$由边表示. 若该点本身为$0$, 则将其代价设为$1$, 表示若将该点选择(流进该点)需要付出一点代价, 反之则将其代价设为$0$. 跑最小费用最大流, 则可得出一个新图, 该新图含义为, 满足题目要求, 且与原图最相似(修改点数最少/尽可能使用原图的边)的构造. 该最小费用最大流的流量即为新图的点数, 费用即为原图中删除(修改)的点数. 则总代价即为 $c + (f - (sum - c))$, 其中$sum$ 为原图中的点数.

\ptitle{[CF1905E] One-X}{shaosy}
\prob 给定一颗线段树. 对于其叶子的所有子集, 求其LCA的和, 数据范围1e18. 具体的, build的定义为build(v,l,r), 令$m = (l+r)/2$(向下取整), 将v和2v与2v+1连边, 后递归调用build(2v,l,m)和build(2v+1,m+1,r)
\sol  考虑单个点的可能贡献. 假设该点的左子树区间长度为$l$, 右子树区间长度为$r$, 显然有点$x$的贡献为$x \times (2^l - 1) \times (2^r - 1)$. 考虑线段树的性质, 发现对相同层的$x$, 其$l$和$r$必然为$\lfloor{\frac{x}{2}}\rfloor$和$\lceil{\frac{x}{2}}\rceil$中的一个. 接下来考虑一个区间长度固定的子树答案. 这一部分可以由两个部分组成: 与$x$相关的($k$) 和 与$x$无关的($b$). 其形式必定如$k\times x + b$

考虑如何更新$k$.首先, $k$必然包括$(2^l-1) \times (2^r - 1)$, 这是由LCA为点$x$的集合数量. 接下来考虑两颗子树$l$和$r$. 首先, $l$和$r$的差至多为1, 假设$l$是较长者. 则$k_l$所能作出的贡献为$2 * v + 1$, 而$k_r$所能作出的贡献为$2 * v$. 于是, 将与$v$相关的部分纳入考虑, 无关部分交给$b$, 即可得出$k = 2k_l + 2k_r + (2^{l}-1) \times (2^{r} - 1)$, $b = b_l + b_r + k_l$. 本质不同的$k,b$对不超过$2\log{n}$个. 可以通过记忆化所搜得到答案.